---
title: Resources, Fees, Ordering
description: Fees and ordering in blockchains
duration: 1 hour
---

# 资源、费用、排序

---

## 概述

<pba-flex center>

1. [费用和排序](#fees--ordering)
1. [执行模型](#execution-models)

</pba-flex>

备注：

- 本讲座的内容有点杂乱。
- 有很多值得讲解的内容，但并非都直接相关。

---

# 费用与排序

---

## 费用与排序

区块链是开放的、共享的系统。
它们的访问不受限制。

但资源是有限的。

---

## 无许可访问

免费的访问“能力”并不意味着免费的访问“成本”。

---

## 线程

区块链运行时是单线程的。

（目前是这样）

---

## 时间

一个区块必须在一定时间内终止。

---

## 网络

除了执行时间，区块需要在整个网络中传播。

---

## 需求

可能有很多人想要同时使用该系统。

但系统需要做出决定：

- 哪些状态转换调用要包含在一个区块中，以及
- 如何对它们进行排序。

---

## 简短插曲 #1

> 区块体包含一组有序的“外部数据”：来自外部世界的数据包，附带零个或多个签名。

备注：

回想一下第一讲的内容。

---

## 简短插曲 #1（续）

这些数据包包括：

- 对系统状态转换函数的调用
- 一些上下文信息（例如，规范版本）
- 可能还有一些额外信息，可帮助区块作者进行优先级排序

---

## 不再简短的插曲 #1（续）

考虑以下数据包：

- 没有附带签名的数据包作为“固有数据”或“无签名外部数据”
- 附带一个或多个签名的数据包作为“交易”

这在一开始会很简单，但随后可能会变得复杂。

---

## 费用模型

不同的区块链有不同的费用模型。

在本讲座中，我们将介绍三种：

- 大小（比特币）
- 步骤计量（以太坊）
- 时间（波卡）*

*（很快还会有空间）

---

## 大小

比特币有一个非常简单的状态转换函数（STF）：即验证签名并重新分配未花费交易输出（UTXO）。

其区块大小是有限的，每个交易都有一定的字节长度（指令、签名等）。

区块作者通常会选择能产生最高总费用的交易集。

---

## 比特币费用市场

<img style="width: 800px" src="./img/3.3-fees-bitcoin-average-fee.png" />

备注：

- 费用市场根据需求而演变

[来源：Y Charts](https://ycharts.com/indicators/bitcoin_average_transaction_fee_btc)
（找不到我真正想要的图表（每字节费率），但可以讨论）

---

## 计量

以太坊的状态转换函数比比特币更复杂，即它是准图灵完备的。

用户可能会提交需要执行未知数量步骤才能终止的交易。

系统使用“Ga s计量”来停止一个交易的执行，并继续执行下一个交易。

---

## 计量

以太坊的状态转换函数定义了一个带有指令集的虚拟机，其中每个指令都需要消耗一定的“Gas”。

用户指定：

- 要使用的最大Gas量
- 他们愿意为每单位Gas支付的费用（以 ETH 为单位）

---

## 计量

每次执行一条指令时，系统都会从最大Gas量中扣除其成本。

如果程序终止，它只收取所使用的Gas费用。

如果Gas用完，它会终止程序。

---

## Gas费率

<img style="width: 800px" src="./img/3.3-fees-ethereum-average-gas-price.png" />

备注：

[来源：Etherscan](https://etherscan.io/chart/gasprice)

---

## 权重

与其在运行时进行计量，不如提前进行计量。

为调度某些调用收取固定*费用。

---

## *固定

```rust
#[pallet::weight(100_000_000)]
fn my_variable_weight_call(input: u8) -> Refund {
	let mut refund: Refund = 0;
	if input > 127 {
		let _ = do_some_heavy_computation();
	} else {
		let _ = do_some_light_computation();
		refund = 80_000_000;
	}
	refund
}
```

---

## 时间

权重是以皮秒（`10E-12`）的执行时间来衡量的。

调用是在某些“标准硬件”上进行基准测试的。

（关于实现二维权重正在进行一些更改）

---

## 权重

使用权重减少了运行时计量的开销，但需要开发人员更加谨慎。

- 必须能够在运行前进行计量
- 因此，用户不应能够部署不受信任的代码
- 执行时没有安全网
- 某些计算是可以的，但应该能够通过调用检查来完成

备注：

示例：

- 用户提供的要迭代的列表的长度
- 批量处理中的调用次数

---

## 简短插曲 #2

一些Gas和权重系统正在演变。

- 以太坊最近添加了 EIP1559，它使用了费用 + 小费机制
- Parity 和 Web3 基金会正在讨论对权重模型的一些更改

---

## 费用策略

区块作者可以使用几种策略来包含交易：

- 只选择费用最高的交易
- 选择费用与{长度、Gas、权重}比率最高的交易

---

## 费用销毁

并非所有费用都必须支付给区块作者（这取决于系统设计）。

实际上，这通常是一个糟糕的设计。区块作者会希望费用上涨，因此可能会进行无操作交易以提高费用。

---

## 费用销毁示例

- 波卡只将 20%的费用支付给区块作者（80% 进入链上国库）
- 自 EIP1559 以来，以太坊会销毁每个交易中的部分费用（其“基础费用”）

在这两个系统中，用户都可以添加“小费”以提高其交易在作者那里的优先级。

---

## 填充区块

根据限制因素的不同，系统对区块填满的限制也不同。

- 比特币：大小（以字节为单位）
- 以太坊：Gas限制（所有交易的Gas限制总和）
- 波卡：权重（所有最大预期权重的总和）

---

## 排序

我们已经选择了一些交易，但运行时是单线程的。

区块作者必须对它们进行排序。

---

## 优先级基础

朴素的解决方案是根据某种“优先级”对挂起的交易进行排序。

然后只包含能够放入一个区块的前 `N` 个交易。

---

## 更高级的方法

但是，对于贪婪的区块作者来说，许多小交易可能会带来更高的费用。

因此，可能存在一组比前 `N` 个交易更有利可图的交易。

甚至有些可能被视为攻击行为。

---

# 执行模型

---

## 事务性执行

大多数区块链都有一个“事务性”执行模型。

也就是说，它们需要被唤醒。

例如，智能合约除非有人向系统提交一个签名的、支付费用的交易，否则不会执行任何代码。

---

## 简短插曲 #3

在这些系统中，所有“来自外部世界的数据包”都是签名的。

某个密钥持有者对授权调用的指令进行签名，并愿意为其执行付费。

现在是进入无签名数据包世界的时候了。

---

## 免费执行

状态机在其状态转换函数中可以有自主函数。

系统设计者可以使这些函数作为状态转换函数的一部分执行。

在这个模型中，区块作者必须执行某些逻辑。

---

## 免费执行

这些额外的函数调用很强大，但需要注意一些事项：

- 它们仍然会消耗执行资源（例如，权重）
- 它们需要某种验证方法（其他节点应该能够接受或拒绝它们）

---

## 钩子

Substrate 讲座将深入介绍这些内容，但现在先看一些 API：

```rust
pub trait Hooks<BlockNumber> {
	fn on_initialize(_n: BlockNumber) -> Weight {}
	fn on_finalize(_n: BlockNumber) {}
	fn on_idle(_n: BlockNumber, _remaining_weight: Weight) -> Weight {}
	fn on_runtime_upgrade() -> Weight {}
	fn offchain_worker(_n: BlockNumber) {}
}
```

来源：[`/frame/support/src/traits/hooks.rs`](https://github.com/paritytech/polkadot-sdk/blob/a13382f/substrate/frame/support/src/traits/hooks.rs)
