---
title: FRAME Benchmarking 2
description: How to benchmark Pallets in FRAME.
duration: 1 hours
---

---
标题: FRAME基准测试2
描述: 如何在FRAME中进行基准测试。
时长: 1小时
---

# FRAME 基准测试

## 第2课

---

## 概述

- 数据库
- 我们在开发过程中的收获
- 最佳实践和常见模式

---

# 数据库

---

### RocksDB

一个用于闪存和内存存储的持久化键值存储系统。

- 键和值是任意字节数组。
- 对于通用数据库来说速度较快。

参见: <https://rocksdb.org/>.

大型项目，要正确配置可能非常棘手。

备注:

（也是Substrate编译时间的一个重要组成部分）。

---

### ParityDB

一个针对区块链应用优化的嵌入式持久化键值存储系统。

- 键和值是任意字节数组。
- 专为高效存储Patricia-Merkle树节点而设计。
  - 大多是固定大小的键。
  - 大多是小值。
  - 均匀分布。
- 针对读取性能进行了优化。

备注:

参见: <https://github.com/paritytech/parity-db/issues/82

主要观点是ParityDB适合triedb模型。
实际上，triedb通过哈希值存储编码后的键。
所以我们不需要RocksDB的索引，也不需要对数据进行排序。
ParityDB默认通过键的哈希值对其内容进行索引，这使得访问速度更快（通常只需访问两个文件的条目，而不是可能的多个B树索引节点）。
对状态值的迭代是通过树结构进行的：不需要使用支持迭代的键值数据库。

RocksDB和ParityDB都使用“事务”作为“批量写入”。
我们通常每个区块运行一个事务（之前所有操作都在内存中进行），速度很快（这可能就是你所指的）。
在区块链中，写入通常是以大批量进行的，当导入新的区块时，必须以原子方式完成。
参见: <https://github.com/paritytech/parity-db>

在这种情况下，并发并不重要，ParityDB会锁定对单个写入者的访问（不支持并发）。
同样，代码力求简单，避免冗余功能：ParityDB中没有缓存（Substrate中有很多缓存）。

'快速提交'：提交时，所有更改都存储在内存中，而实际写入WriteAheadLog是以异步方式进行的。

待办事项：合并<https://github.com/paritytech/parity-db/issues/82>中的内容

---

### ParityDB: 探测哈希表

ParityDB是作为一个探测哈希表实现的。

- 与日志结构合并（LSM）树不同。
  - 用于Apache AsterixDB、Bigtable、HBase、LevelDB、Apache Accumulo、SQLite4、Tarantool、RocksDB、WiredTiger、Apache Cassandra、InfluxDB、ScyllaDB等。
- 因为我们在树操作中不需要键排序或迭代。
- 这意味着读取性能是常数时间，而不是$O(\log{n})$。

---

### ParityDB: 固定大小值表

- 每列数据存储在一组256个值表中，其中255个表包含大小范围在32 KB以内的条目。

<div class="text-smaller">

```rust
const SIZES: [u16; SIZE_TIERS - 1] = [
	32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 46, 47, 48, 50, 51, 52, 54, 55, 57, 58, 60,
	62, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 88, 90, 93, 95, 98, 101, 103, 106, 109,
	112, 115, 119, 122, 125, 129, 132, 136, 140, 144, 148, 152, 156, 160, 165, 169, 174, 179, 183,
	189, 194, 199, 205, 210, 216, 222, 228, 235, 241, 248, 255, 262, 269, 276, 284, 292, 300, 308,
	317, 325, 334, 344, 353, 363, 373, 383, 394, 405, 416, 428, 439, 452, 464, 477, 490, 504, 518,
	532, 547, 562, 577, 593, 610, 627, 644, 662, 680, 699, 718, 738, 758, 779, 801, 823, 846, 869,
	893, 918, 943, 969, 996, 1024, 1052, 1081, 1111, 1142, 1174, 1206, 1239, 1274, 1309, 1345,
	1382, 1421, 1460, 1500, 1542, 1584, 1628, 1673, 1720, 1767, 1816, 1866, 1918, 1971, 2025, 2082,
	2139, 2198, 2259, 2322, 2386, 2452, 2520, 2589, 2661, 2735, 2810, 2888, 2968, 3050, 3134, 3221,
	3310, 3402, 3496, 3593, 3692, 3794, 3899, 4007, 4118, 4232, 4349, 4469, 4593, 4720, 4850, 4984,
	5122, 5264, 5410, 5559, 5713, 5871, 6034, 6200, 6372, 6548, 6729, 6916, 7107, 7303, 7506, 7713,
	7927, 8146, 8371, 8603, 8841, 9085, 9337, 9595, 9860, 10133, 10413, 10702, 10998, 11302, 11614,
	11936, 12266, 12605, 12954, 13312, 13681, 14059, 14448, 14848, 15258, 15681, 16114, 16560,
	17018, 17489, 17973, 18470, 18981, 19506, 20046, 20600, 21170, 21756, 22358, 22976, 23612,
	24265, 24936, 25626, 26335, 27064, 27812, 28582, 29372, 30185, 31020, 31878, 32760,
];
```

</div>

- 第256个值表存储大小超过32 KB的条目，这些条目会被分成多个部分。

---

### ParityDB: 固定大小值表

- 超过99%的树节点大小小于32kb。
- 小值只需要两次读取：一次索引查找和一次值表查找。
- 大小超过32kb的值可能需要多次值表读取，但这种情况很少见。
- 有助于最小化未使用的磁盘空间。
- 例如，如果你存储一个670字节的值，它不会放入662字节的存储桶中，但会放入680字节的存储桶中，只浪费10字节的空间。

备注:

大多数值都很小，这一事实使我们能够通过索引来定位每个值，并有一种简单的机制来重用已删除值的空间，而不会产生碎片，也不需要定期进行垃圾回收。

---

### ParityDB: 异步写入

- ParityDB API公开的是同步函数，但底层的IO是异步的。
- `commit`函数将数据库事务添加到写入队列中，更新提交覆盖层，并尽快返回。
- 实际的写入操作在后台进行。
- 提交覆盖层允许区块导入管道在数据库仍在为前一个区块写入更改时，开始执行下一个区块。

---

### 实际基准测试和注意事项

现在让我们抛开概念，谈谈实际的数据。

---

### 常见运行时数据大小和性能

<br />

<div class="flex-container">
<div class="left">

- 大多数运行时值是80字节，这些值是用户账户。
- 当然，这取决于你链的逻辑。

</div>
<div class="right" style="padding-left: 10px;">

<div class="r-stack">
	<img style="height: 500px;" src="./img/polkadot-size-histogram.png" />
	<img style="height: 500px;" class="fragment" src="./img/polkadot-size-histogram-alpha.png" />
</div>
</div>

备注:

键大小的影响是稍微大一点的编码节点。
自从以太坊的扩展性问题出现后，我们通常关注状态节点。
不过，使用ParityDB对其他内容的访问进行审计和增强可能也很有趣。

查看更多详细信息:

<https://substrate.stackexchange.com/questions/525/how-expensive-is-it-to-access-storage-items/526#526>

---

### RocksDB与ParityDB的性能对比

在32 KB时，每增加4 KB，性能就会下降。

<img style="height: 500px" src="./img/paritydb-vs-rocksdb-read.png" />

---

### RocksDB的不一致性

<img style="width: 1200px;" src="./img/rocksdb-hiccups.png" />

在进行基准测试时，我们发现了RocksDB的一些非常奇怪但可重现的问题。

---

## 我们尝试过的事情

## 我们学到的东西

---

## 隔离数据库基准测试（PR #5586）

<pba-cols>
<pba-col>

### 我们尝试过…

对整个外部调用进行基准测试，包括直接在基准测试中对数据库操作的权重进行测试。我们想要:

- 填充数据库使其“满”
- 刷新数据库缓存
- 运行基准测试

</pba-col>
<pba-col>

### 我们学到了…

RocksDB太不稳定，无法给出可重现的结果，而且填充速度非常慢。
所以我们使用内存数据库进行基准测试。

<img style="height: 200px;" src="./img/rocksdb-hiccups.png" />

</pba-col>
</pba-cols>

---

## 修复非线性事件（PR #5795）

<pba-cols>
<pba-col>

### 我们尝试过…

执行整个区块，增加每个区块中的事务数量。我们原本期望执行时间呈线性增长，但实际上是超线性增长！

<img style="height: 250px;" src="./img/nonlinear-events.png" />

</pba-col>
<pba-col>

### 我们学到了…

每次我们追加一个新事件时，我们都在Wasm边界上传递不断增长的事件对象。

我们更新了追加API，以便只推送新数据。

<img style="height: 200px;" src="./img/event-fix.png" />

</pba-col>
</pba-cols>

---

## 启用权重退款（PR #5584）

<pba-cols>
<pba-col>

### 我们尝试过…

为了安全起见，为所有外部调用分配最坏情况下的权重。

在许多情况下，如果不读取存储，我们就无法准确知道外部调用的权重……而这是不允许的！

</pba-col>
<pba-col>

### 我们学到了…

许多外部调用的最坏情况权重与它们的平均权重有很大不同。

所以我们允许外部调用返回实际消耗的权重，并退还该权重以及任何权重费用。

</pba-col>
</pba-cols>

---

## 可定制的权重信息（PR #6575）

<pba-cols>
<pba-col>

### 我们尝试过…

直接在pallet中记录权重信息和基准测试结果。

</pba-col>
<pba-col>

### 我们学到了…

这很难更新，不可定制，并且对于自定义pallet配置来说不准确。

</pba-col>
</pba-cols>

所以我们将权重定义移到了在运行时特征中配置的可定制关联类型中。

```rust
#[weight = 45_000_000 + T::DbWeight::get().reads_writes(1,1)]
```

变成了...

```rust
#[weight = T::WeightInfo::transfer()]
```

---

## 继承调用权重语法（PR #13932）

```rust
#[pallet::call(weight(<T as Config>::WeightInfo))]
impl<T: Config> Pallet<T> {

	pub fn create(
		...
```

---

## 自定义基准测试返回/错误（PR #9517）

```rust
override_benchmark {
	let b in 1 .. 1000;
	let caller = account::<T::AccountId>("caller", 0, 0);
}: {
	Err(BenchmarkError::Override(
		BenchmarkResult {
			extrinsic_time: 1_234_567_890,
			reads: 1337,
			writes: 420,
			..Default::default()
		}
	))?;
}
```

---

## 负 Y 轴截距处理（PR #11806）

---

## 多维权重（问题 #12176）

```rust
#[derive(
    Encode, Decode, MaxEncodedLen, TypeInfo, Eq, PartialEq, Copy, Clone, RuntimeDebug, Default,
)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct Weight {
    #[codec(compact)]
    /// 基于某些参考硬件使用的计算时间的权重。
    ref_time: u64,
    #[codec(compact)]
    /// 有效性证明所使用的存储空间的权重。
    proof_size: u64,
}
```

---

# 最佳实践和常见模式

---

## 初始权重计算必须轻量级

- 在交易队列中，我们需要知道权重以确定它是否适合放入区块。
- 此权重计算必须轻量级！
- 不允许存储读取！

示例：

- 转账基础：约 50 微秒
- 存储读取：约 25 微秒

---

## 设置边界并假设最坏情况！

- 添加一个配置特征，为某些项设置一个上限，并且在权重中，最初假设为这种最坏情况。
- 在外部函数执行期间，找出项的实际长度/大小，并将权重退还为实际使用的量。

---

## 为每个逻辑路径分离基准测试

- 可能不清楚函数中的哪个逻辑路径是“最坏情况”。
- 为函数可能采用的每个逻辑路径创建一个基准测试。
- 确保每个基准测试都在测试该路径的最坏情况。

---

## 权重定义中的比较运算符

```rust
#[pallet::weight(
    T::WeightInfo::path_a()
  .max(T::WeightInfo::path_b())
  .max(T::WeightInfo::path_c())
)]
```

---

## 保持外部函数简单

- 外部函数逻辑越复杂，准确衡量其权重就越困难。
- 这会导致更高的前期权重、潜在的更高交易费用以及更低效的区块打包。

---

## 使用多个简单的外部函数

- 利用 UI/UX、批处理调用和类似的下游工具来简化外部函数逻辑。

示例：

- 投票和关闭投票（“最后一次投票”）是独立的外部函数。

---

## 最小化 `on_finalize` 的使用

- `on_finalize` 是区块中最后发生的事情，并且必须执行以使区块成功。
- 可变权重可能导致超重的区块。

<img style="height: 200px;" src="./img/on-finalize.svg" />

---

## 将逻辑和权重转移到 `on_initialize`

- `on_initialize` 发生在区块开始时，在外部函数之前。
- 可以调整外部函数的数量以支持可用资源。
- `on_finalize` 的权重应该包含在 `on_initialize` 权重或外部函数权重中。

---

## 理解模块钩子的限制

- Substrate 的一个强大功能是允许运行时配置来实现模块配置特征。
- 然而，这个功能很容易被滥用，导致基准测试不准确。

---

## 保持钩子为常量时间

- 示例：用于账户创建和账户销毁的余额钩子。
- 基准测试不知道如何正确设置状态来测试任意钩子。
- 因此，你必须保持钩子为常量时间，除非模块另有规定。

---

<!--.slide: data-background-color="#4A2439" -->

# 问题
