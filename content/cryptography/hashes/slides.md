---
title: Hash Functions
description: Hash functions in Substrate
duration: 1 hour
---

### 哈希函数

---

## 简介

我们经常需要一个简洁的数据表示形式，同时期望这个表示形式能够唯一地代表原始数据 这就是哈希函数的作用，它可以将任意长度的数据映射到一个固定长度的输出，这个输出通常被称为哈希值或摘要 

##### 一个“指纹”

---

## 哈希函数的特性

一个好的哈希函数应该具备以下特性：

1. **接受任意大小的输入**：哈希函数应该能够处理任意长度的数据输入 
2. **输出固定长度**：无论输入数据的大小如何，哈希函数的输出长度都是固定的 
3. **快速计算**：哈希函数的计算速度应该非常快，这样才能在实际应用中高效地处理大量数据 
4. **难以逆向**：从哈希值反推原始数据在计算上是不可行的，这意味着即使知道哈希值，也无法确定原始数据是什么 
5. **抗碰撞性**：找到两个不同输入数据产生相同哈希值的概率极低 

---

## 哈希函数API

一个哈希函数通常应该：

- 接受一个无界输入大小的字节数组 `[u8]`
- 返回一个固定长度的输出（例如，一个32字节的数组） 

```rust
fn hash(s: &[u8]) -> [u8; 32];
```

---

## 示例

**短输入（5字节）：**

```text
hash('hello') =
 0x1c8aff950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac8
```

**大输入（1.2MB）：**

```text
hash(Harry_Potter_series_as_string) =
 0xc4d194054f03dc7155ccb080f1e6d8519d9d6a83e916960de973c93231aca8f4
```

---

## 输入敏感性

哈希函数对输入的微小变化非常敏感 即使只改变输入数据的一个比特，哈希值也会完全不同 

```text
hash('hello') =
 0x1c8aff950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac8
```

```text
hash('hellp') =
 0x7bc9c272894216442e0ad9df694c50b6a0e12f6f4b3d9267904239c63a7a0807
```

---

<!--.slide: data-background-color="#4A2439" -->

# Rust演示

## 哈希消息

Notes:

请参阅本课的Jupyter笔记本和/或HackMD备忘单 

1. 使用更长的消息
1. 对其进行哈希处理
1. 验证哈希值上的签名

---

## 速度

有些哈希函数设计为慢速，这在密码哈希中很有用，因为它可以减缓暴力攻击的速度 但对于我们的目的，我们通常希望哈希函数快速 

---

## 著名的哈希算法

<pba-flex center>

- xxHash a.k.a TwoX（非加密）
- MD5
- SHA1
- RIPEMD-160
- SHA2-256（又名SHA256）等
- SHA3
- Keccak
- Blake2

xxHash64 比 Blake2 快约 20 倍 

</pba-flex>

---

## 区块链中的哈希函数

<pba-flex center>

- 比特币：SHA2-256 和 RIPMD-160
- 以太坊：Keccak-256（尽管通过EVM支持其他算法）
- Polkadot：Blake2 和 xxHash（尽管通过主机函数支持其他算法）

</pba-flex>

Notes:

Substrate 还实现了为每个哈希器提供 160、256 和 512 位输出的 trait 

练习：编写自己的基准测试脚本，比较这些算法在不同输入大小下的性能 

---

### 哈希基准测试

<img rounded style="height: 650px" src="./img/crypto-bench.png" />

Notes:

加密哈希算法的基准测试 
来源：<https://www.blake2.net/>

---

#### XXHash - 快速哈希算法

<img rounded style="height: 600px" src="./img/Benchmark-XXHash.png" />

Notes:

XX-hash 算法的基准测试 
来源：<https://github.com/Cyan4973/xxHash#benchmarks>

---

## 非加密哈希函数

非加密哈希函数在安全性保证方面较弱，但在性能上有所提升 在输入数据不是恶意的情况下，可以使用非加密哈希函数 

**如果有疑问，请使用加密哈希函数 **

---

## 单向性

给定一个哈希值，应该很难找到一个输入值（原像），使得该输入值经过哈希函数处理后得到给定的哈希值 

也就是说，给定 `H(x)`，应该很难找到 `x` 

Notes:

我们有时会在原像中添加随机字节，以防止基于上下文的猜测（例如，如果你正在哈希“石头、剪刀、布”，那么在没有添加随机数的情况下，找到原像是微不足道的 ）

---

## 第二原像攻击

给定一个哈希值和一个原像，应该很难找到另一个原像，使得这两个原像经过哈希函数处理后得到相同的哈希值 

给定 `H(x)`，应该很难找到任何 `x'`，使得 `H(x) == H(x')` 

Notes:

由于大多数签名方案都会进行某种内部哈希处理，因此这种第二原像也会通过签名验证 

---

## 抗碰撞性

应该很难找到两个消息，它们哈希到相同的值 

应该很难找到 `x` 和 `y`，使得 `H(x) == H(y)` 

---

## 抗碰撞性

**与第二原像攻击的区别：**

在第二原像攻击中，攻击者只控制一个输入 

在碰撞攻击中，攻击者控制两个输入 他们可能试图欺骗某人签署一个消息 

Notes:

攻击者意图用另一个消息来冒充签名者 一般来说，即使只找到一个哈希碰撞，也通常会导致哈希函数被认为是不安全的 

---

## 生日问题

<pba-cols>
<pba-col style="font-size:smaller">

> 有23个人，有6%的机会有人在特定日期出生，但有50%的机会两个人共享生日 

- 必须将每个输出与其他每个输出进行比较，而不是与单个输出进行比较 
- 随着尝试次数的增加，可能的“命中”数量呈指数增长，从而将预期成功降低到特定目标的平方根 

</pba-col>
<pba-col>

<img style="width: 700px; border-radius: 0;" src="./img/birthday-problem.svg" />

</pba-col>
</pba-cols>

---

## 生日攻击

因此，通过生日攻击，可以在 $\sqrt {2^{n}}=2^{^{\frac{n}{2}}}$ 次尝试中找到哈希函数的碰撞，其中 $\cdot 2^{^{\frac{n}{2}}}$ 是经典的原像抵抗安全性 

因此，哈希函数的安全性仅为比特空间的一半 

Notes:

例如，一个256位的哈希输出提供2^128的安全性 

- <https://en.wikipedia.org/wiki/Birthday_attack>
- <https://en.wikipedia.org/wiki/Birthday_problem>

---

## 部分抵抗

应该很难找到一个哈希值的部分碰撞或“第二”原像 

- 比特币PoW是一种部分原像攻击 
- 前缀/后缀原像攻击抵抗减少了地址欺骗的UI攻击机会 
- 前缀碰撞抵抗对于某些加密数据结构的成本合理化很重要 

---

## 哈希函数选择

<pba-flex center>

当用户（即攻击者）可以控制输入时，必须使用加密哈希函数 

当输入不可控时（例如，系统分配的索引），可以使用非加密哈希函数，并且速度更快 

Notes:

只有在用户无法选择原像的情况下才安全，例如系统分配的索引 

Keccak 可用于以太坊兼容性 

---

<!--.slide: data-background-color="#4A2439" -->

# 应用

---

## 加密保证

让我们看看哈希在哪些方面提供了加密保证 

---v

## 机密性

发送或公开哈希值可以保持数据的机密性，因为只有那些已经知道数据的人才能识别哈希值代表的数据 

加密和非加密哈希函数都可以用于此目的 _只有在输入空间足够大的情况下_ 

---v

## 机密性反例

想象一下通过发布哈希值来玩石头、剪刀、布，然后再揭示 然而，如果消息是“石头”、“剪刀”或“布”，输出将始终是：

```text
hash('rock') = 0x10977e4d68108d418408bc9310b60fc6d0a750c63ccef42cfb0ead23ab73d102
hash('paper') = 0xea923ca2cdda6b54f4fb2bf6a063e5a59a6369ca4c4ae2c4ce02a147b3036a21
hash('scissors') = 0x389a2d4e358d901bfdf22245f32b4b0a401cc16a4b92155a2ee5da98273dad9a
```

另一个玩家不需要撤销哈希函数就知道你玩了什么！

Notes:

数据空间必须足够大 
在输入的哈希中添加一些随机性可以解决这个问题 添加 x 位的随机性可以在哈希上提供 x 位的安全性 

---v

## 真实性

任何人都可以制作哈希，因此哈希本身不提供真实性保证 

---v

## 完整性

哈希值会随着数据的变化而变化，因此它确实提供了完整性保证 

---v

## 不可否认性

哈希本身不能提供不可否认性，因为它们不能提供真实性 

然而，如果用于其他提供不可否认性的加密原语中，$H(D)$ 提供与 $D$ 本身相同的不可否认性 

Notes:

这是数字签名的关键 然而，重要的是要认识到，如果 $D$ 是保密的，$H(D)$ 基本上是没有意义的 

---

## 内容派生索引

哈希函数可用于生成数据库的确定性和唯一查找键 

Notes:

给定一些固定的属性，如用户预先知道的 ID 和其他元数据，他们总是可以找到包含他们正在寻找的所有内容的数据库条目 

---

## 数据完整性检查

在点对点网络中，文件块可以被哈希标识，以便对等方可以请求和验证块是否属于更大的、内容寻址的文件 

Notes:

在 [Bittorrent](https://en.wikipedia.org/wiki/BitTorrent) 中，每个文件块都通过哈希进行标识，这样对等方就可以请求和验证块是否属于更大的、内容寻址的文件 

---

## 账户抽象

公钥可用于通过签署指令来授权操作 

哈希函数的特性允许使用其他类型的表示 

---

## 公钥表示

由于哈希可以作为其他数据的唯一表示，因此这些数据可以包括公钥 

系统可以将多个密钥大小映射到固定长度（例如，用作数据库键） 

例如，ECDSA 公钥是 33 字节：

```text
Public key (hex):
  0x02d82cdc83a966aaabf660c4496021918466e61455d2bc403c34bde8148b227d7a

Hash of pub key:
  0x8fea32b38ed87b4739378aa48f73ea5d0333b973ee72c5cb7578b143f82cf7e9
                                                                    ^^
```

---

## 承诺方案

通常需要在不存储或揭示信息的情况下承诺某些信息：

- 预测市场可能希望在确认/反驳事件发生后才揭示预测 
- 系统用户可能希望在不将提案存储在系统上的情况下讨论提案 

然而，参与者不应该能够修改他们的预测或提案 

---

## 承诺-揭示

<pba-flex center>

1. 分享数据的哈希值作为承诺（$c$）
2. 揭示数据本身（$d$）

<pba-flex>

通常会在消息中添加一些随机性，以扩展输入集的大小：

$$ hash(message + randomness) => commitment $$

<pba-flex style="font-size: smaller;">

承诺：`0x97c9b8d5019e51b227b7a13cd2c753cae2df9d3b435e4122787aff968e666b0b`

---

## 揭示

带有一些随机性的消息：

<pba-flex style="font-size: smaller;">

> "我预测鲍里斯·约翰逊将在2022年7月7日辞职 facc8d3303c61ec1808f00ba612c680f"

---

## 数据标识符

有时候人们希望在一个地方存储信息，并在另一个地方引用它 为了引用，他们需要一些“指纹”或摘要 

例如，他们可能会投票决定在系统内执行一些特权指令 

信息的哈希值可以简洁地表示信息，并承诺其创建者不会更改它 

---

## 数据结构（简）

这是后面课程的重点 

Notes:

现在，只是一个简短的介绍 

---

## 基于指针的链表

基于指针的链表是编程的基础 

但是指针独立于它们引用的数据，因此可以在维护列表的同时修改数据 

也就是说，基于指针的链表不是防篡改的 

<img src="./img/Hash-Chains.png" />

---

## 基于哈希的链表

基于哈希的链表使它们引用的数据相关联 哈希函数的特性使其成为此应用的良好选择 

列表中任何一点的任何更改都会导致所有哈希值的下游更改 

---

## 默克尔树

<img  src="./img/Merkle-Tree.png" />

Notes:

每个叶子是一些数据对象的哈希值，每个节点是其子节点的哈希值 

---

## 证明

默克尔树允许许多与本课程其余部分相关的证明，例如某些数据对象是树的成员，而无需传递整个树 

**_更多信息在下一课中 _**

---

<!--.slide: data-background-color="#4A2439" -->

# 问题
---

## 子系统中哈希示例

**Sr25519签名**

Sr25519在其签名过程中对消息进行哈希处理 

**交易**

在子系统中，当指令长度超过256字节时，密钥持有者在指令的哈希值上签名 

---

## 数据库键

**TwoX64**在用户（即攻击者）无法控制输入时是安全的，例如当数据库键是系统分配的索引时 

**Blake2**应该用于其他所有情况 

_再次强调，有一整节课是关于基于哈希的数据结构的 _

---

## 子系统中哈希的其他用途

哈希还用于：

<pba-flex center>

- 生成多重签名账户
- 生成系统控制的账户
- 生成代理控制的账户
- 表示提案
- 表示声明（例如资产陷阱）

</pba-flex>
